// protocrap-codegen/src/generator.rs

use super::protocrap;

use std::collections::HashMap;
use std::panic;

use super::comments::extract_comments;
use super::names::*;
use super::tables;
use allocator_api2::alloc::Global;
use anyhow::Result;
use proc_macro2::TokenStream;
use protocrap::google::protobuf::DescriptorProto::ProtoType as DescriptorProto;
use protocrap::google::protobuf::EnumDescriptorProto::ProtoType as EnumDescriptorProto;
use protocrap::google::protobuf::FieldDescriptorProto::Type;
use protocrap::google::protobuf::FileDescriptorProto::ProtoType as FileDescriptorProto;
use protocrap::google::protobuf::FileDescriptorSet::ProtoType as FileDescriptorSet;
use protocrap::reflection::is_in_oneof;
use protocrap::reflection::is_repeated;
use protocrap::reflection::needs_has_bit;
use protocrap::{ProtobufMut, ProtobufRef};
use quote::{format_ident, quote};

#[allow(dead_code)]
pub(crate) fn generate_file_set(file_set: &FileDescriptorSet) -> Result<TokenStream> {
    // Build a tree of packages to handle hierarchical namespaces properly
    // This avoids duplicate module declarations for packages like:
    //   - protobuf_test_messages.proto2
    //   - protobuf_test_messages.proto3
    // which should both go under a single pub mod protobuf_test_messages { ... }

    #[derive(Default)]
    struct PackageNode {
        file_contents: Vec<TokenStream>,
        children: std::collections::BTreeMap<String, PackageNode>,
    }

    let mut root = PackageNode::default();

    // Organize files into package tree
    for file in file_set.file() {
        let content = generate_file_content(file)?;
        let package = file.package();

        if package.is_empty() {
            // Root package
            root.file_contents.push(content);
        } else {
            // Navigate/create tree nodes
            let parts: Vec<&str> = package.split('.').collect();
            let mut node = &mut root;
            for part in parts {
                node = node.children.entry(part.to_string()).or_default();
            }
            node.file_contents.push(content);
        }
    }

    // Generate code from tree
    fn generate_node(node: &PackageNode) -> TokenStream {
        let mut items = node.file_contents.clone();

        for (name, child_node) in &node.children {
            let child_content = generate_node(child_node);
            let ident = format_ident!("{}", name);
            items.push(quote! {
                pub mod #ident {
                    use super::protocrap;
                    #child_content
                }
            });
        }

        quote! { #(#items)* }
    }

    let contents = generate_node(&root);

    Ok(quote! {
        // Auto-generated by protocrap-codegen
        // DO NOT EDIT

        #contents
    })
}

/// Generate the content of a single file (without package module wrapping)
fn generate_file_content(file: &FileDescriptorProto) -> Result<TokenStream> {
    let mut items = Vec::new();

    // Extract comments from source_code_info
    let comments = extract_comments(file);

    // Generate enums
    for enum_type in file.enum_type() {
        let name = enum_type.name();
        items.push(generate_enum(enum_type.as_ref(), &comments, name)?);
    }

    // Generate messages
    for (idx, message) in file.message_type().iter().enumerate() {
        let name = message.name();
        items.push(generate_message(message, file, &comments, name, vec![idx])?);
    }

    let file_descriptor = if file.name()
        == protocrap::google::protobuf::FileDescriptorProto::ProtoType::file_descriptor().name()
    {
        // Special case: generate FileDescriptorProto static for descriptor.proto itself
        let mut pool = protocrap::descriptor_pool::DescriptorPool::new(&Global);
        pool.add_file(file);
        let mut arena = protocrap::arena::Arena::new(&Global);
        let mut dyn_file_descriptor =
            pool.create_message("google.protobuf.FileDescriptorProto", &mut arena)?;
        // Roundtrip file descriptor using protobuf encoding/decoding that is schema evolution safe
        let serialized = file.encode_vec::<100>()?;
        if !dyn_file_descriptor.decode_flat::<100>(&mut arena, &serialized) {
            anyhow::bail!("Failed to decode FileDescriptorProto for descriptor.proto");
        }
        super::static_gen::generate_static_dynamic(
            &dyn_file_descriptor,
            "google.protobuf.FileDescriptorProto",
            "protocrap",
        )?
    } else {
        super::static_gen::generate_static_dynamic(
            &file.as_dyn(),
            "google.protobuf.FileDescriptorProto",
            "protocrap",
        )?
    };

    // Generate FILE_DESCRIPTOR_PROTO in a dedicated module to avoid name collisions
    // when multiple files share the same package
    // Create a unique module name based on the proto filename (without path and extension)
    let filename = std::path::Path::new(file.name())
        .file_stem()
        .and_then(|s| s.to_str())
        .unwrap_or("file");
    let mod_name = format_ident!("_{}", sanitize_module_name(filename));

    items.push(quote! {
        #[doc(hidden)]
        pub mod #mod_name {
            use super::protocrap;
            pub static FILE_DESCRIPTOR_PROTO: protocrap::google::protobuf::FileDescriptorProto::ProtoType = #file_descriptor;
        }
    });

    Ok(quote! { #(#items)* })
}

fn generate_enum(
    enum_desc: &EnumDescriptorProto,
    comments: &HashMap<String, String>,
    name_prefix: &str,
) -> Result<TokenStream> {
    let name = format_ident!("{}", enum_desc.name());

    // Get doc comment for the enum
    let enum_doc = make_doc_comment(comments.get(name_prefix));

    // Deduplicate enum values - Rust doesn't support aliased enum variants
    // Keep only the first variant for each numeric value
    let mut seen_values = std::collections::HashSet::new();
    let unique_values: Vec<_> = enum_desc
        .value()
        .iter()
        .filter(|v| seen_values.insert(v.number()))
        .collect();

    // Enum variants with doc comments
    let variants: Vec<_> = unique_values
        .iter()
        .map(|v| {
            let variant_name = format_ident!("{}", v.name());
            let number = v.number();
            let value_key = format!("{}.{}", name_prefix, v.name());
            let variant_doc = make_doc_comment(comments.get(&value_key));
            quote! {
                #variant_doc
                #variant_name = #number
            }
        })
        .collect();

    // from_i32 match arms - use the deduplicated values
    let from_i32_arms: Vec<_> = unique_values
        .iter()
        .map(|v| {
            let variant_name = format_ident!("{}", v.name());
            let number = v.number();
            quote! { #number => Some(Self::#variant_name) }
        })
        .collect();

    Ok(quote! {
        #enum_doc
        #[repr(i32)]
        #[derive(Debug, Clone, Copy, PartialEq, Eq)]
        #[allow(non_camel_case_types)]
        pub enum #name {
            #(#variants,)*
        }

        impl #name {
            pub const fn from_i32(value: i32) -> Option<Self> {
                match value {
                    #(#from_i32_arms,)*
                    _ => None,
                }
            }

            pub const fn to_i32(self) -> i32 {
                self as i32
            }
        }
    })
}

/// Convert a comment string to doc comment tokens
fn make_doc_comment(comment: Option<&String>) -> TokenStream {
    match comment {
        Some(text) => {
            let lines: Vec<_> = text.lines().map(|line| format!(" {}", line)).collect();
            quote! {
                #(#[doc = #lines])*
            }
        }
        None => quote! {},
    }
}

fn generate_message(
    message: &DescriptorProto,
    file: &FileDescriptorProto,
    comments: &HashMap<String, String>,
    name_prefix: &str,
    path: Vec<usize>,
) -> Result<TokenStream> {
    let msg = generate_message_impl(message, file, comments, name_prefix, path)?;
    let name = format_ident!("{}", sanitize_field_name(message.name()));

    Ok(quote! {
        #[allow(non_snake_case)]
        pub mod #name {
            use super::protocrap;
            #[allow(unused_imports)]
            use protocrap::generated_code_only::Protobuf;
            #msg
        }
    })
}

fn generate_message_impl(
    message: &DescriptorProto,
    file: &FileDescriptorProto,
    comments: &HashMap<String, String>,
    name_prefix: &str,
    path: Vec<usize>,
) -> Result<TokenStream> {
    // Nested types first

    let mut nested_items = Vec::new();
    for (idx, nested) in message.nested_type().iter().enumerate() {
        let nested_prefix = format!("{}.{}", name_prefix, nested.name());
        let mut nested_path = path.clone();
        nested_path.push(idx);
        nested_items.push(generate_message(
            nested,
            file,
            comments,
            &nested_prefix,
            nested_path,
        )?);
    }

    let nested_enums: Vec<_> = message
        .enum_type()
        .iter()
        .map(|e| {
            let enum_prefix = format!("{}.{}", name_prefix, e.name());
            generate_enum(e.as_ref(), comments, &enum_prefix)
        })
        .collect::<Result<Vec<_>, _>>()?;

    // Calculate has bits (excludes oneof fields)
    let has_bit_fields: Vec<_> = message
        .field()
        .iter()
        .filter(|f| needs_has_bit(f))
        .collect();

    let has_bits_count = has_bit_fields.len();
    let has_bits_words = has_bits_count.div_ceil(32);

    // Count oneofs - each needs a u32 discriminant in metadata
    let oneof_count = message.oneof_decl().len();
    let metadata_words = has_bits_words + oneof_count;

    // Group fields by oneof index
    let mut oneof_fields: std::collections::HashMap<i32, Vec<_>> = std::collections::HashMap::new();
    for field in message.field() {
        if is_in_oneof(field.as_ref()) {
            oneof_fields
                .entry(field.oneof_index())
                .or_default()
                .push(field.as_ref());
        }
    }

    // Generate union types for each oneof
    let mut union_defs = Vec::new();
    let mut union_fields = Vec::new();
    for (idx, oneof) in message.oneof_decl().iter().enumerate() {
        let union_name = format_ident!("{}Union", to_pascal_case(oneof.name()));
        let oneof_field_name = format_ident!("{}", sanitize_field_name(oneof.name()));

        if let Some(fields) = oneof_fields.get(&(idx as i32)) {
            let variants: Vec<_> = fields
                .iter()
                .map(|f| {
                    let variant_name = format_ident!("{}", sanitize_field_name(f.name()));
                    let variant_type = rust_field_type_tokens(f);
                    quote! { #variant_name: core::mem::ManuallyDrop<#variant_type> }
                })
                .collect();

            union_defs.push(quote! {
                #[repr(C)]
                pub union #union_name {
                    #(pub #variants,)*
                }

                impl Default for #union_name {
                    fn default() -> Self {
                        unsafe { core::mem::zeroed() }
                    }
                }
            });

            union_fields.push(quote! { #oneof_field_name: #union_name });
        }
    }

    // Regular struct fields (non-oneof)
    let regular_fields: Vec<_> = message
        .field()
        .iter()
        .filter(|f| !is_in_oneof(f.as_ref()))
        .map(|field| {
            let field_name = format_ident!("{}", sanitize_field_name(field.name()));
            let field_type = rust_field_type_tokens(field);
            (field.number(), quote! { #field_name: #field_type })
        })
        .collect();

    let mut sorted_regular_fields = regular_fields.clone();
    sorted_regular_fields.sort_by_key(|(field_num, _)| *field_num);

    let struct_field_names: Vec<_> = message
        .field()
        .iter()
        .filter(|f| !is_in_oneof(f.as_ref()))
        .map(|f| format_ident!("{}", sanitize_field_name(f.name())))
        .collect();

    let (_, regular_fields): (Vec<_>, Vec<_>) = regular_fields.into_iter().unzip();
    let (_, sorted_regular_fields): (Vec<_>, Vec<_>) = sorted_regular_fields.into_iter().unzip();

    // Build has_bit map
    let has_bit_map: std::collections::HashMap<_, _> = has_bit_fields
        .iter()
        .enumerate()
        .map(|(i, f)| (f.number(), i))
        .collect();

    // Build oneof info map: field_number -> (discriminant_word_index, oneof_field_name)
    // discriminant_word_index = has_bits_words + oneof_idx (index into metadata array)
    let oneof_info: std::collections::HashMap<i32, (usize, String)> = message
        .field()
        .iter()
        .filter(|f| is_in_oneof(f.as_ref()))
        .map(|f| {
            let oneof_idx = f.oneof_index() as usize;
            let discriminant_word_idx = has_bits_words + oneof_idx;
            let oneof_name = message.oneof_decl()[oneof_idx].name().to_string();
            (f.number(), (discriminant_word_idx, oneof_name))
        })
        .collect();

    // Accessor methods
    let accessors = generate_accessors(message, &has_bit_map, comments, name_prefix)?;

    // Protobuf trait impl
    let protobuf_impl = generate_protobuf_impl();

    let table = tables::generate_table(message, &has_bit_map, &oneof_info, Some(file.syntax()))?;

    // Build path to FILE_DESCRIPTOR_PROTO in the file-specific module
    let filename = std::path::Path::new(file.name())
        .file_stem()
        .and_then(|s| s.to_str())
        .unwrap_or("file");
    let file_mod_name = format_ident!("_{}", sanitize_module_name(filename));
    let file_descriptor_ident = format_ident!("FILE_DESCRIPTOR_PROTO");

    let package = file.package();
    let file_descriptor_path = if package.is_empty() {
        quote! { crate::#file_mod_name::#file_descriptor_ident }
    } else {
        let mut parts: Vec<_> = package.split('.').map(|s| format_ident!("{}", s)).collect();
        parts.push(file_mod_name);
        parts.push(file_descriptor_ident);

        quote! { crate::#(#parts)::* }
    };

    let message_descriptor_accessor = build_descriptor_accessor(&path);

    // Names for union fields in struct (for from_static)
    let union_field_names: Vec<_> = message
        .oneof_decl()
        .iter()
        .map(|oneof| format_ident!("{}", sanitize_field_name(oneof.name())))
        .collect();

    // Get doc comment for this message
    let message_doc = make_doc_comment(comments.get(name_prefix));

    // Doc strings for generated methods
    let proto_file = file.name();
    let message_name = name_prefix.trim_start_matches('.');
    let clear_doc = format!(
        " Resets all fields of `{}` to their default values.",
        message_name
    );
    let file_descriptor_doc = format!(" Returns the file descriptor for `{}`.", proto_file);
    let descriptor_proto_doc = format!(" Returns the descriptor for `{}`.", message_name);

    Ok(quote! {
        #(#nested_items)*
        #(#nested_enums)*

        #(#union_defs)*

        #message_doc
        #[repr(C)]
        #[derive(Default)]
        pub struct ProtoType {
            metadata: [u32; #metadata_words],
            #(#regular_fields,)*
            #(#union_fields,)*
        }

        impl core::fmt::Debug for ProtoType {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                protocrap::generated_code_only::debug_message(self, f)
            }
        }

        impl ProtoType {
            #[doc(hidden)]
            #[allow(clippy::too_many_arguments)]
            pub const fn from_static(
                metadata: [u32; #metadata_words],
                #(#sorted_regular_fields,)*
                #(#union_fields,)*
            ) -> Self {
                Self {
                    metadata,
                    #(#struct_field_names,)*
                    #(#union_field_names,)*
                }
            }

            #[doc = #clear_doc]
            pub fn clear(&mut self) {
                *self = Self::default();
            }

            #[doc = #file_descriptor_doc]
            pub const fn file_descriptor() -> &'static protocrap::google::protobuf::FileDescriptorProto::ProtoType {
                &#file_descriptor_path
            }

            #[doc = #descriptor_proto_doc]
            pub const fn descriptor_proto() -> &'static protocrap::google::protobuf::DescriptorProto::ProtoType {
                #message_descriptor_accessor
            }

            #accessors
        }

        #protobuf_impl
        #table
    })
}

fn unescape_proto_string(s: &str) -> Result<Vec<u8>> {
    let mut result = Vec::new();
    let mut chars = s.chars();

    while let Some(ch) = chars.next() {
        if ch == '\\' {
            match chars.next() {
                Some('n') => result.push('\n' as u8),
                Some('t') => result.push('\t' as u8),
                Some('r') => result.push('\r' as u8),
                Some('\\') => result.push('\\' as u8),
                Some('"') => result.push('"' as u8),
                Some('\'') => result.push('\'' as u8),
                Some('x') => {
                    // \xHH - hex byte
                    let hex: String = chars.by_ref().take(2).collect();
                    if let Ok(byte) = u8::from_str_radix(&hex, 16) {
                        result.push(byte);
                    } else {
                        anyhow::bail!("Invalid hex escape: \\x{}", hex);
                    }
                }
                Some(c) if c.is_ascii_digit() => {
                    // \ooo - octal byte (up to 3 digits)
                    let mut octal = String::from(c);
                    for _ in 0..2 {
                        if let Some(next) = chars.clone().next() {
                            if next.is_ascii_digit() && next < '8' {
                                octal.push(next);
                                chars.next();
                            } else {
                                break;
                            }
                        }
                    }
                    if let Ok(byte) = u8::from_str_radix(&octal, 8) {
                        result.push(byte);
                    } else {
                        anyhow::bail!("Invalid octal escape: \\{}", octal);
                    }
                }
                Some(c) => {
                    anyhow::bail!("Unknown escape sequence: \\{}", c);
                }
                None => {
                    anyhow::bail!("Incomplete escape sequence at end of string");
                }
            }
        } else {
            result.push(ch as u8);
        }
    }

    Ok(result)
}

fn parse_primitive_default(
    field: &protocrap::google::protobuf::FieldDescriptorProto::ProtoType,
) -> Option<TokenStream> {
    let Some(default_str) = field.get_default_value() else {
        return None;
    };
    match field.r#type()? {
        Type::TYPE_INT32 | Type::TYPE_SINT32 | Type::TYPE_SFIXED32 => {
            let value = default_str.parse::<i32>().unwrap();
            if value != 0 {
                Some(quote! { #value })
            } else {
                None
            }
        }
        Type::TYPE_INT64 | Type::TYPE_SINT64 | Type::TYPE_SFIXED64 => {
            let value = default_str.parse::<i64>().unwrap();
            if value != 0 {
                Some(quote! { #value })
            } else {
                None
            }
        }
        Type::TYPE_UINT32 | Type::TYPE_FIXED32 => {
            let value = default_str.parse::<u32>().unwrap();
            if value != 0 {
                Some(quote! { #value })
            } else {
                None
            }
        }
        Type::TYPE_UINT64 | Type::TYPE_FIXED64 => {
            let value = default_str.parse::<u64>().unwrap();
            if value != 0 {
                Some(quote! { #value })
            } else {
                None
            }
        }
        Type::TYPE_BOOL => match default_str {
            "true" => Some(quote! { true }),
            "false" => Some(quote! { false }),
            _ => panic!("Invalid boolean default value: {}", default_str),
        },
        Type::TYPE_FLOAT => {
            // Handle special float values
            match default_str {
                "inf" => Some(quote! { f32::INFINITY }),
                "-inf" => Some(quote! { f32::NEG_INFINITY }),
                "nan" => Some(quote! { f32::NAN }),
                _ => {
                    let value = default_str.parse::<f32>().unwrap();
                    if value != 0.0 {
                        Some(quote! { #value })
                    } else {
                        None
                    }
                }
            }
        }
        Type::TYPE_DOUBLE => {
            // Handle special double values
            match default_str {
                "inf" => Some(quote! { f64::INFINITY }),
                "-inf" => Some(quote! { f64::NEG_INFINITY }),
                "nan" => Some(quote! { f64::NAN }),
                _ => {
                    let value = default_str.parse::<f64>().unwrap();
                    if value != 0.0 {
                        Some(quote! { #value })
                    } else {
                        None
                    }
                }
            }
        }
        Type::TYPE_STRING => {
            if default_str.is_empty() {
                return None;
            } else {
                Some(quote! { #default_str })
            }
        }
        Type::TYPE_BYTES => match unescape_proto_string(default_str) {
            Ok(unescaped) => {
                if unescaped.is_empty() {
                    None
                } else {
                    Some(quote! { &[#(#unescaped),*] })
                }
            }
            Err(_) => panic!("Invalid bytes default value: {}", default_str),
        },
        Type::TYPE_ENUM => {
            if default_str.is_empty() {
                return None;
            }
            let enum_type = rust_type_tokens(field);
            let variant = format_ident!("{}", default_str);
            Some(quote! { Some(#enum_type::#variant) })
        }
        Type::TYPE_MESSAGE | Type::TYPE_GROUP => {
            unreachable!("Messages cannot have default values")
        }
    }
}

fn generate_accessors(
    message: &DescriptorProto,
    has_bit_map: &std::collections::HashMap<i32, usize>,
    comments: &HashMap<String, String>,
    name_prefix: &str,
) -> Result<TokenStream> {
    let mut methods = Vec::new();

    // Calculate has_bits_words for discriminant offset calculation
    let has_bits_count = message
        .field()
        .iter()
        .filter(|f| needs_has_bit(f.as_ref()))
        .count();
    let has_bits_words = has_bits_count.div_ceil(32);

    for field in message.field() {
        let field_name = format_ident!("{}", sanitize_field_name(field.name()));

        // Get field doc comment
        let field_key = format!("{}.{}", name_prefix, field.name());
        let field_doc = make_doc_comment(comments.get(&field_key));
        let has_doc_str = format!(" Returns whether the `{}` field is set.", field.name());
        let has_doc = quote! { #[doc = #has_doc_str] };
        let clear_doc_str = format!(" Clears the `{}` field.", field.name());
        let clear_doc = quote! { #[doc = #clear_doc_str] };

        // Handle oneof fields specially
        if is_in_oneof(field.as_ref()) {
            let oneof_idx = field.oneof_index() as usize;
            let oneof = &message.oneof_decl()[oneof_idx];
            let oneof_field_name = format_ident!("{}", sanitize_field_name(oneof.name()));
            let discriminant_word_idx = has_bits_words + oneof_idx;
            let field_number = field.number() as u32;

            let setter_name = format_ident!("set_{}", field_name);
            let has_name = format_ident!("has_{}", field_name);
            let clear_name = format_ident!("clear_{}", field_name);

            // Generate has_<field> - check if discriminant matches this field
            methods.push(quote! {
                #has_doc
                pub fn #has_name(&self) -> bool {
                    self.metadata[#discriminant_word_idx] == #field_number
                }
            });

            match field.r#type().unwrap() {
                Type::TYPE_STRING => {
                    let optional_name = format_ident!("get_{}", field_name);
                    methods.push(quote! {
                        #field_doc
                        pub fn #field_name(&self) -> &str {
                            if self.#has_name() {
                                unsafe { (*self.#oneof_field_name.#field_name).as_str() }
                            } else {
                                ""
                            }
                        }

                        #field_doc
                        pub fn #optional_name(&self) -> Option<&str> {
                            if self.#has_name() {
                                Some(unsafe { (*self.#oneof_field_name.#field_name).as_str() })
                            } else {
                                None
                            }
                        }

                        #field_doc
                        pub fn #setter_name(&mut self, value: &str, arena: &mut protocrap::arena::Arena) {
                            if !self.#has_name() {
                                self.metadata[#discriminant_word_idx] = #field_number;
                                self.#oneof_field_name.#field_name = core::mem::ManuallyDrop::new(protocrap::containers::String::new());
                            }
                            unsafe { (*self.#oneof_field_name.#field_name).assign(value, arena) };
                        }

                        #clear_doc
                        pub fn #clear_name(&mut self) {
                            self.metadata[#discriminant_word_idx] = 0;
                        }
                    });
                }
                Type::TYPE_BYTES => {
                    let optional_name = format_ident!("get_{}", field_name);
                    methods.push(quote! {
                        #field_doc
                        pub fn #field_name(&self) -> &[u8] {
                            if self.#has_name() {
                                unsafe { (*self.#oneof_field_name.#field_name).slice() }
                            } else {
                                &[]
                            }
                        }

                        #field_doc
                        pub fn #optional_name(&self) -> Option<&[u8]> {
                            if self.#has_name() {
                                Some(unsafe { (*self.#oneof_field_name.#field_name).slice() })
                            } else {
                                None
                            }
                        }

                        #field_doc
                        pub fn #setter_name(&mut self, value: &[u8], arena: &mut protocrap::arena::Arena) {
                            if !self.#has_name() {
                                self.metadata[#discriminant_word_idx] = #field_number;
                                self.#oneof_field_name.#field_name = core::mem::ManuallyDrop::new(protocrap::containers::Bytes::new());
                            }
                            unsafe { (*self.#oneof_field_name.#field_name).assign(value, arena) };
                        }

                        #clear_doc
                        pub fn #clear_name(&mut self) {
                            self.metadata[#discriminant_word_idx] = 0;
                        }
                    });
                }
                Type::TYPE_MESSAGE | Type::TYPE_GROUP => {
                    let msg_type = rust_type_tokens(field);
                    let field_name_mut = format_ident!("{}_mut", field_name);
                    methods.push(quote! {
                        #field_doc
                        pub fn #field_name(&self) -> Option<&#msg_type::ProtoType> {
                            if self.#has_name() {
                                use core::ops::Deref;
                                Some(unsafe { self.#oneof_field_name.#field_name.deref() })
                            } else {
                                None
                            }
                        }

                        #field_doc
                        pub fn #field_name_mut(&mut self, arena: &mut protocrap::arena::Arena) -> &mut #msg_type::ProtoType {
                            if !self.#has_name() {
                                self.metadata[#discriminant_word_idx] = #field_number;
                                self.#oneof_field_name.#field_name = core::mem::ManuallyDrop::new(protocrap::TypedMessage::<#msg_type::ProtoType>::new_in(arena).unwrap());
                            }
                            use core::ops::DerefMut;
                            unsafe { self.#oneof_field_name.#field_name.deref_mut() }
                        }

                        #clear_doc
                        pub fn #clear_name(&mut self) {
                            self.metadata[#discriminant_word_idx] = 0;
                        }
                    });
                }
                Type::TYPE_ENUM => {
                    let enum_type = rust_type_tokens(field);
                    methods.push(quote! {
                        #field_doc
                        pub fn #field_name(&self) -> Option<#enum_type> {
                            if self.#has_name() {
                                #enum_type::from_i32(unsafe { *self.#oneof_field_name.#field_name })
                            } else {
                                None
                            }
                        }

                        #field_doc
                        pub fn #setter_name(&mut self, value: #enum_type) {
                            self.metadata[#discriminant_word_idx] = #field_number;
                            self.#oneof_field_name.#field_name = core::mem::ManuallyDrop::new(value.to_i32());
                        }

                        #clear_doc
                        pub fn #clear_name(&mut self) {
                            self.metadata[#discriminant_word_idx] = 0;
                        }
                    });
                }
                _ => {
                    // Scalar types
                    let return_type = rust_element_type_tokens(field);
                    methods.push(quote! {
                        #field_doc
                        pub fn #field_name(&self) -> #return_type {
                            if self.#has_name() {
                                unsafe { *self.#oneof_field_name.#field_name }
                            } else {
                                Default::default()
                            }
                        }

                        #field_doc
                        pub fn #setter_name(&mut self, value: #return_type) {
                            self.metadata[#discriminant_word_idx] = #field_number;
                            self.#oneof_field_name.#field_name = core::mem::ManuallyDrop::new(value);
                        }

                        #clear_doc
                        pub fn #clear_name(&mut self) {
                            self.metadata[#discriminant_word_idx] = 0;
                        }
                    });
                }
            }
            continue;
        }

        // Regular (non-oneof) fields

        if is_repeated(field) {
            // Repeated field accessor
            if field.r#type() == Some(Type::TYPE_MESSAGE)
                || field.r#type() == Some(Type::TYPE_GROUP)
            {
                // Repeated message field
                let msg_type = rust_type_tokens(field);
                let field_name_mut = format_ident!("{}_mut", field_name);
                let add_field_name = format_ident!("add_{}", field_name);
                methods.push(quote! {
                    #field_doc
                    pub const fn #field_name(&self) -> &[protocrap::TypedMessage<#msg_type::ProtoType>] {
                        self.#field_name.slice()
                    }

                    #field_doc
                    pub fn #field_name_mut(&mut self) -> &mut protocrap::containers::RepeatedField<protocrap::TypedMessage<#msg_type::ProtoType>> {
                        &mut self.#field_name
                    }

                    #field_doc
                    pub fn #add_field_name(&mut self, arena: &mut protocrap::arena::Arena) -> &mut #msg_type::ProtoType {
                        let msg = protocrap::TypedMessage::<#msg_type::ProtoType>::new_in(arena).unwrap();
                        self.#field_name.push(msg, arena);
                        self.#field_name.last_mut().unwrap()
                    }
                });
                continue;
            }
            let element_type = rust_element_type_tokens(field);
            let field_name_mut = format_ident!("{}_mut", field_name);
            methods.push(quote! {
                #field_doc
                pub const fn #field_name(&self) -> &[#element_type] {
                    self.#field_name.slice()
                }

                #field_doc
                pub fn #field_name_mut(&mut self) -> &mut protocrap::containers::RepeatedField<#element_type> {
                    &mut self.#field_name
                }
            });
        } else {
            let setter_name = format_ident!("set_{}", field_name);
            let optional_setter_name = format_ident!("set_optional_{}", field_name);
            let optional_name = format_ident!("get_{}", field_name);
            let clear_name = format_ident!("clear_{}", field_name);
            let has_name = format_ident!("has_{}", field_name);
            let has_bit = if let Some(has_bit) = has_bit_map.get(&field.number()).cloned() {
                methods.push(quote! {
                    #has_doc
                    pub const fn #has_name(&self) -> bool {
                        protocrap::generated_code_only::as_object(self).has_bit(#has_bit as u8)
                    }
                });
                has_bit as u32
            } else {
                0
            };
            match field.r#type().unwrap() {
                Type::TYPE_STRING => {
                    // Parse default value if present
                    let default_value = parse_primitive_default(field);

                    let getter_impl =
                        if has_bit_map.contains_key(&field.number()) && default_value.is_some() {
                            let default_tokens = default_value.unwrap();
                            quote! {
                                if self.#has_name() {
                                    self.#field_name.as_str()
                                } else {
                                    #default_tokens
                                }
                            }
                        } else {
                            quote! { self.#field_name.as_str() }
                        };

                    methods.push(quote! {
                        #field_doc
                        pub const fn #field_name(&self) -> &str {
                            #getter_impl
                        }

                        #field_doc
                        pub const fn #optional_name(&self) -> Option<&str> {
                            if self.#has_name() {
                                Some(self.#field_name.as_str())
                            } else {
                                None
                            }
                        }

                        #field_doc
                        pub fn #setter_name(&mut self, value: &str, arena: &mut protocrap::arena::Arena) {
                            protocrap::generated_code_only::as_object_mut(self).set_has_bit(#has_bit);
                            self.#field_name.assign(value, arena);
                        }

                        pub fn #optional_setter_name(&mut self, value: Option<&str>, arena: &mut protocrap::arena::Arena) {
                            match value {
                                Some(v) => self.#setter_name(v, arena),
                                None => self.#clear_name(),
                            }
                        }

                        #clear_doc
                        pub fn #clear_name(&mut self) {
                            protocrap::generated_code_only::as_object_mut(self).clear_has_bit(#has_bit);
                            self.#field_name.clear();
                        }
                    });
                }
                Type::TYPE_BYTES => {
                    let default_value = parse_primitive_default(field);
                    let getter_impl = if let Some(default_tokens) = default_value {
                        quote! {
                            if self.#has_name() {
                                self.#field_name.slice()
                            } else {
                                #default_tokens
                            }
                        }
                    } else {
                        quote! { self.#field_name.slice() }
                    };
                    methods.push(quote! {
                        #field_doc
                        pub const fn #field_name(&self) -> &[u8] {
                            #getter_impl
                        }

                        #field_doc
                        pub const fn #optional_name(&self) -> Option<&[u8]> {
                            if self.#has_name() {
                                Some(self.#field_name.slice())
                            } else {
                                None
                            }
                        }

                        #field_doc
                        pub fn #setter_name(&mut self, value: &[u8], arena: &mut protocrap::arena::Arena) {
                            protocrap::generated_code_only::as_object_mut(self).set_has_bit(#has_bit);
                            self.#field_name.assign(value, arena);
                        }

                        pub fn #optional_setter_name(&mut self, value: Option<&[u8]>, arena: &mut protocrap::arena::Arena) {
                            match value {
                                Some(v) => self.#setter_name(v, arena),
                                None => self.#clear_name(),
                            }
                        }

                        #clear_doc
                        pub fn #clear_name(&mut self) {
                            protocrap::generated_code_only::as_object_mut(self).clear_has_bit(#has_bit);
                            self.#field_name.clear();
                        }
                    });
                }
                Type::TYPE_MESSAGE | Type::TYPE_GROUP => {
                    let msg_type = rust_type_tokens(field);
                    let field_name_mut = format_ident!("{}_mut", field_name);
                    methods.push(quote! {
                        #has_doc
                        pub const fn #has_name(&self) -> bool {
                            self.#field_name.is_some()
                        }

                        #field_doc
                        pub const fn #field_name(&self) -> Option<&#msg_type::ProtoType> {
                            self.#field_name.get()
                        }

                        #field_doc
                        pub fn #field_name_mut(&mut self, arena: &mut protocrap::arena::Arena) -> &mut #msg_type::ProtoType {
                            self.#field_name.get_or_init(arena).unwrap()
                        }

                        #clear_doc
                        pub fn #clear_name(&mut self) {
                            self.#field_name.clear();
                        }
                    });
                }
                Type::TYPE_ENUM => {
                    let enum_type = rust_type_tokens(field);
                    let default_value = parse_primitive_default(field);

                    let getter_impl = if let Some(default_tokens) = default_value {
                        quote! {
                            if self.#has_name() {
                                #enum_type::from_i32(self.#field_name)
                            } else {
                                #default_tokens
                            }
                        }
                    } else {
                        quote! { #enum_type::from_i32(self.#field_name) }
                    };

                    methods.push(quote! {
                        #field_doc
                        pub const fn #field_name(&self) -> Option<#enum_type> {
                            #getter_impl
                        }

                        #field_doc
                        pub fn #setter_name(&mut self, value: #enum_type) {
                            protocrap::generated_code_only::as_object_mut(self).set_has_bit(#has_bit);
                            self.#field_name = value.to_i32();
                        }

                        pub fn #optional_setter_name(&mut self, value: Option<#enum_type>) {
                            match value {
                                Some(v) => self.#setter_name(v),
                                None => self.#clear_name(),
                            }
                        }

                        #clear_doc
                        pub fn #clear_name(&mut self) {
                            protocrap::generated_code_only::as_object_mut(self).clear_has_bit(#has_bit);
                            self.#field_name = 0;
                        }
                    });
                }
                _ => {
                    // Scalar types
                    let return_type = rust_element_type_tokens(field);

                    // Parse default value if present
                    let default_value = parse_primitive_default(field);

                    let getter_impl = if default_value.is_some() {
                        let default_tokens = default_value.unwrap();
                        quote! {
                            if self.#has_name() {
                                self.#field_name
                            } else {
                                #default_tokens
                            }
                        }
                    } else {
                        quote! { self.#field_name }
                    };

                    methods.push(quote! {
                        #field_doc
                        pub const fn #field_name(&self) -> #return_type {
                            #getter_impl
                        }

                        #field_doc
                        pub const fn #optional_name(&self) -> Option<#return_type> {
                            if self.#has_name() {
                                Some(self.#field_name)
                            } else {
                                None
                            }
                        }

                        #field_doc
                        pub fn #setter_name(&mut self, value: #return_type) {
                            protocrap::generated_code_only::as_object_mut(self).set_has_bit(#has_bit);
                            self.#field_name = value;
                        }

                        pub fn #optional_setter_name(&mut self, value: Option<#return_type>) {
                            match value {
                                Some(v) => self.#setter_name(v),
                                None => self.#clear_name(),
                            }
                        }

                        #clear_doc
                        pub fn #clear_name(&mut self) {
                            protocrap::generated_code_only::as_object_mut(self).clear_has_bit(#has_bit);
                            self.#field_name = Default::default();
                        }
                    });
                }
            }
        }
    }

    Ok(quote! { #(#methods)* })
}

fn build_descriptor_accessor(path: &[usize]) -> TokenStream {
    if path.is_empty() {
        panic!("Message path cannot be empty");
    }

    let mut accessor = quote! { Self::file_descriptor() };

    for (level, &index) in path.iter().enumerate() {
        let index_lit = proc_macro2::Literal::usize_unsuffixed(index);

        if level == 0 {
            // First level: file's message_type array
            accessor = quote! {
                #accessor.message_type()[#index_lit].as_ref()
            };
        } else {
            // Nested levels: need as_ref() to access nested_type on &T
            accessor = quote! {
                #accessor.nested_type()[#index_lit].as_ref()
            };
        }
    }

    accessor
}

fn generate_protobuf_impl() -> TokenStream {
    quote! {
        impl protocrap::generated_code_only::Protobuf for ProtoType {
            fn table() -> &'static protocrap::generated_code_only::Table {
                &TABLE.table
            }
        }
    }
}
