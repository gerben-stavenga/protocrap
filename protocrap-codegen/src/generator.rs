// protocrap-codegen/src/generator.rs

use crate::names::*;
use crate::static_gen;
use crate::tables;
use anyhow::Result;
use proc_macro2::TokenStream;
use prost_reflect::DescriptorPool;
use prost_reflect::DynamicMessage;
use prost_types::*;
use quote::{format_ident, quote};

pub fn generate_file_set(
    file_set: &FileDescriptorSet,
) -> Result<TokenStream> {
    let mut items = Vec::new();

    for file in &file_set.file {
        items.push(generate_file(file)?);
    }

    Ok(quote! {
        // Auto-generated by protocrap-codegen
        // DO NOT EDIT

        #(#items)*
    })
}

fn generate_file(file: &FileDescriptorProto) -> Result<TokenStream> {
    let mut items = Vec::new();

    // Generate enums
    for enum_type in &file.enum_type {
        items.push(generate_enum(enum_type)?);
    }

    // Generate messages
    for message in &file.message_type {
        items.push(generate_message(message, file)?);
    }

    let file_descriptor = {
        use prost::Message;
        let encoded = file.encode_to_vec();

        // Get the descriptor from global pool
        let pool = DescriptorPool::global();
        let descriptor = pool
            .get_message_by_name("google.protobuf.FileDescriptorProto")
            .ok_or(anyhow::anyhow!("FileDescriptorProto not found in global pool"))?;

        // Decode as DynamicMessage
        let dynamic = DynamicMessage::decode(descriptor.clone(), &encoded[..])?;

        // Generate static initializer
        static_gen::generate_static_dynamic(&dynamic)?
    };
    items.push(quote! {
        pub static FILE_DESCRIPTOR_PROTO: protocrap::google::protobuf::FileDescriptorProto::ProtoType = #file_descriptor;
    });
    let mut res = quote! { #(#items)* };
    for namespace in file.package.as_deref().unwrap_or(&"").split('.').rev() {
        if namespace.is_empty() {
            continue;
        }
        let ident = format_ident!("{}", namespace);
        res = quote! {
        pub mod #ident {
            use super::protocrap;

            #res
        } };
    }
    Ok(res)
}

fn generate_enum(
    enum_desc: &EnumDescriptorProto,
) -> Result<TokenStream> {
    let name = format_ident!("{}", enum_desc.name.as_ref().unwrap());

    // Enum variants
    let variants: Vec<_> = enum_desc
        .value
        .iter()
        .map(|v| {
            let variant_name = format_ident!("{}", v.name.as_ref().unwrap());
            let number = v.number.unwrap();
            quote! { #variant_name = #number }
        })
        .collect();

    // from_i32 match arms
    let from_i32_arms: Vec<_> = enum_desc
        .value
        .iter()
        .map(|v| {
            let variant_name = format_ident!("{}", v.name.as_ref().unwrap());
            let number = v.number.unwrap();
            quote! { #number => Some(Self::#variant_name) }
        })
        .collect();

    Ok(quote! {
        #[repr(i32)]
        #[derive(Debug, Clone, Copy, PartialEq, Eq)]
        #[allow(non_camel_case_types)]
        pub enum #name {
            #(#variants,)*
        }

        impl #name {
            pub fn from_i32(value: i32) -> Option<Self> {
                match value {
                    #(#from_i32_arms,)*
                    _ => None,
                }
            }

            pub fn to_i32(self) -> i32 {
                self as i32
            }
        }
    })
}

fn generate_message(
    message: &DescriptorProto,
    _file: &FileDescriptorProto,
) -> Result<TokenStream> {
    let msg = generate_message_impl(message, _file)?;
    let name = format_ident!("{}", sanitize_field_name(message.name()));

    Ok(quote! {
        #[allow(non_snake_case)]
        pub mod #name {
            use super::protocrap;
            #[allow(unused_imports)]
            use protocrap::Protobuf;
            #msg
        }
    })
}

fn generate_message_impl(
    message: &DescriptorProto,
    _file: &FileDescriptorProto,
) -> Result<TokenStream> {
    // Nested types first
    let nested_items: Vec<_> = message
        .nested_type
        .iter()
        .map(|nested| generate_message(nested, _file))
        .collect::<Result<Vec<_>, _>>()?;

    let nested_enums: Vec<_> = message
        .enum_type
        .iter()
        .map(generate_enum)
        .collect::<Result<Vec<_>, _>>()?;

    // Calculate has bits
    let has_bit_fields: Vec<_> = message.field.iter().filter(|f| needs_has_bit(f)).collect();

    let has_bits_count = has_bit_fields.len();
    let has_bits_words = (has_bits_count + 31) / 32;
    let has_bits_words = has_bits_words.max(1);

    // Struct fields
    let struct_fields: Vec<_> = message
        .field
        .iter()
        .map(|field| {
            let field_name = format_ident!("{}", sanitize_field_name(field.name.as_ref().unwrap()));
            let field_type = rust_field_type_tokens(field);
            (
                field_name.clone(),
                (field.number(), quote! { #field_name: #field_type }),
            )
        })
        .collect();

    let (struct_field_names, struct_fields): (Vec<_>, Vec<_>) = struct_fields.into_iter().unzip();
    let mut sorted_struct_fields: Vec<_> = struct_fields.clone();
    sorted_struct_fields.sort_by_key(|(field_num, _)| *field_num);

    let (_, struct_fields): (Vec<_>, Vec<_>) = struct_fields.into_iter().unzip();
    let (_, sorted_struct_fields): (Vec<_>, Vec<_>) = sorted_struct_fields.into_iter().unzip();

    // Build has_bit map
    let has_bit_map: std::collections::HashMap<_, _> = has_bit_fields
        .iter()
        .enumerate()
        .map(|(i, f)| (f.number.unwrap(), i))
        .collect();

    // Accessor methods
    let accessors = generate_accessors(message, &has_bit_map)?;

    // Protobuf trait impl
    let protobuf_impl = generate_protobuf_impl();

    // Tables
    let encoding_table = tables::generate_encoding_table(message, &has_bit_map)?;
    let decoding_table = tables::generate_decoding_table(message, &has_bit_map)?;

    Ok(quote! {
        #(#nested_items)*
        #(#nested_enums)*

        #[repr(C)]
        #[derive(Debug, Default)]
        pub struct ProtoType {
            has_bits: [u32; #has_bits_words],
            #(#struct_fields,)*
        }

        impl ProtoType {
            pub const fn from_static(
                has_bits: [u32; #has_bits_words],
                #(#sorted_struct_fields,)*
            ) -> Self {
                Self {
                    has_bits,
                    #(#struct_field_names,)*
                }
            }
            #accessors
        }

        #protobuf_impl
        #encoding_table
        #decoding_table
    })
}

fn generate_accessors(
    message: &DescriptorProto,
    has_bit_map: &std::collections::HashMap<i32, usize>,
) -> Result<TokenStream> {
    use field_descriptor_proto::{Label, Type};

    let mut methods = Vec::new();

    for field in &message.field {
        let field_name = format_ident!("{}", sanitize_field_name(field.name.as_ref().unwrap()));
        let is_repeated = field.label() == Label::Repeated;

        if is_repeated {
            // Repeated field accessor
            let element_type = rust_element_type_tokens(field);
            let field_name_mut = format_ident!("{}_mut", field_name);
            methods.push(quote! {
                pub fn #field_name(&self) -> &[#element_type] {
                    unsafe { std::mem::transmute(self.#field_name.slice()) }
                }

                pub fn #field_name_mut(&mut self) -> &mut protocrap::containers::RepeatedField<#element_type> {
                    &mut self.#field_name
                }
            });
        } else {
            match field.r#type() {
                Type::String => {
                    methods.push(quote! {
                        pub fn #field_name(&self) -> &str {
                            &self.#field_name
                        }
                    });

                    if let Some(&has_bit) = has_bit_map.get(&field.number.unwrap()) {
                        let setter_name = format_ident!("set_{}", field_name);
                        methods.push(quote! {
                            pub fn #setter_name(&mut self, value: &str) {
                                self.as_object_mut().set_has_bit(#has_bit as u32);
                                self.#field_name.assign(value);
                            }
                        });
                    }
                }
                Type::Bytes => {
                    methods.push(quote! {
                        pub fn #field_name(&self) -> &[u8] {
                            &self.#field_name
                        }
                    });

                    if let Some(&has_bit) = has_bit_map.get(&field.number.unwrap()) {
                        let setter_name = format_ident!("set_{}", field_name);
                        methods.push(quote! {
                            pub fn #setter_name(&mut self, value: &[u8]) {
                                self.as_object_mut().set_has_bit(#has_bit as u32);
                                self.#field_name.assign(value);
                            }
                        });
                    }
                }
                Type::Message | Type::Group => {
                    let msg_type = rust_type_tokens(field);
                    methods.push(quote! {
                        pub fn #field_name(&self) -> Option<&#msg_type::ProtoType> {
                            if self.#field_name.0.is_null() {
                                None
                            } else {
                                Some(unsafe { &*(self.#field_name.0 as *const #msg_type::ProtoType) })
                            }
                        }
                    });

                    let setter_name = format_ident!("{}_mut", field_name);
                    methods.push(quote! {
                        pub fn #setter_name(&mut self, arena: &mut protocrap::arena::Arena) -> &mut #msg_type::ProtoType {
                            let object = self.#field_name;
                            if object.0.is_null() {
                                let new_object = protocrap::base::Object::create(
                                    std::mem::size_of::<#msg_type::ProtoType>() as u32,
                                    arena
                                );
                                self.#field_name = protocrap::base::Message(new_object);
                            }
                            unsafe { &mut *(self.#field_name.0 as *mut #msg_type::ProtoType) }
                        }
                    });
                }
                Type::Enum => {
                    let enum_type = rust_type_tokens(field);
                    methods.push(quote! {
                        pub fn #field_name(&self) -> Option<#enum_type> {
                            #enum_type::from_i32(self.#field_name)
                        }
                    });

                    if let Some(&has_bit) = has_bit_map.get(&field.number.unwrap()) {
                        let setter_name = format_ident!("set_{}", field_name);
                        methods.push(quote! {
                            pub fn #setter_name(&mut self, value: #enum_type) {
                                self.as_object_mut().set_has_bit(#has_bit as u32);
                                self.#field_name = value.to_i32();
                            }
                        });
                    }
                }
                _ => {
                    // Scalar types
                    let return_type = rust_scalar_type_tokens(field);
                    methods.push(quote! {
                        pub fn #field_name(&self) -> #return_type {
                            self.#field_name
                        }
                    });

                    if let Some(&has_bit) = has_bit_map.get(&field.number.unwrap()) {
                        let setter_name = format_ident!("set_{}", field_name);
                        methods.push(quote! {
                            pub fn #setter_name(&mut self, value: #return_type) {
                                self.as_object_mut().set_has_bit(#has_bit as u32);
                                self.#field_name = value;
                            }
                        });
                    }
                }
            }
        }
    }

    Ok(quote! { #(#methods)* })
}

fn generate_protobuf_impl() -> TokenStream {
    quote! {
        impl protocrap::Protobuf for ProtoType {
            fn encoding_table() -> &'static [protocrap::encoding::TableEntry] {
                &ENCODING_TABLE.0
            }

            fn decoding_table() -> &'static protocrap::decoding::Table {
                &DECODING_TABLE.0
            }
        }
    }
}

fn needs_has_bit(field: &FieldDescriptorProto) -> bool {
    use field_descriptor_proto::{Label, Type};

    if field.label() == Label::Repeated {
        return false;
    }

    !matches!(field.r#type(), Type::Message | Type::Group)
}
